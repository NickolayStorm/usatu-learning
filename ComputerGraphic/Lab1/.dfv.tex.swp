\documentclass[13pt]{extarticle}
\usepackage{pdfpages}
\usepackage[a4paper,pdftex]{geometry}	
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fix-cm}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}





% Using typewriter font: \ttfamily inside \lstset

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}


%Images
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{wrapfig}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{figure}}


\geometry{top=2cm} % отступ сверху
\geometry{bottom=2.5cm} % отступ снизу
\geometry{left=2cm} % отступ справа
\geometry{right=2cm}


\author{Пахтусов Н. Г., ПРО-306}
\makeatletter

%Roman num
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}


\begin{document}

\begin{center}
\thispagestyle{empty} 

Федеральное государственное бюджетное образовательное учереждение высшего \\
профессионального образования\\
<<Уфимский государственный авиационный технический университет>>
\vspace*{\fill}
\begingroup
\centering

Отчёт по лабораторной работе №1\\
по дисциплине <<Компьютерная графика>>\\
<<Точка в 3D пространстве>>

\endgroup
\vspace*{\fill}

\end{center}

\begin{flushright}

Выполнил:\\
\@author \\
Проверил: \\
Верхотуров М. А.

\end{flushright}

\begin{center}
$\bullet$ Уфа, 2015
\end{center}

\clearpage

\tableofcontents

\clearpage

\section{Постановка задачи}
\subsection{Содержательная постановка задачи}
	Содержание экрана:
	\begin{itemize}
		\item пространственный чертеж с изображением точки Т, ее проекций Т$_1$, Т$_2$, Т$_3$ и линий связи;
		\item  комплексный чертеж с изображением проекций Т$_1$, Т$_2$, Т$_3$ и линий связи.
		\item ползунковые переключатели для интерактивного изменения координат (x, y, z) точки Т и угла $\alpha$.
	\end{itemize}
	Динамика:
	\begin{itemize}
		\item при изменении координат точки Т и угла $\alpha$, должны изменяться соответствующие проекции и сама точка Т на пространственном и комплексном чертежах.
	\end{itemize}
\subsection{Формальная постановка задачи}
	\begin{figure}[h]
		\center{\includegraphics{Images/frst}}
		%\caption{Формальная постановка задачи.}
	\end{figure}
	
\section{Теоретическая часть}
\subsection{Ортогональная система трех плоскостей проекций}
В основу построения любого изображения положена операция проецирования.

Сущность метода ортогонального проецирования заключается в том, что предмет проецируется на две взаимно перпендикулярные плоскости лучами, ортогональными (перпендикулярными) к этим осям.

Одну из плоскостей проекций П$_1$ располагают горизонтально, а вторую, П$_2$, -- вертикально. Плоскость П$_1$ называют горизонтальной плоскостью проекций, П$_2$ -- фронтальной. Плоскости П$_1$ и П$_2$ бесконечны и непрозрачны.

При построении проекций необходимо помнить, что проекцией точки на плоскость называется основание перпендикуляра, опущенного из этой точки на данную плоскость. Проекцию точки А на горизонтальную плоскость называют горизонтальной проекцией и обозначают А$_1$, проекцию точки А на фронтальную плоскость -- фронтальной проекцией и обозначают А$_2$. Каждая из них является основанием перпендикуляра, опущенного из данной точки А соответственно и на плоскости П$_1$ и П$_2$. Две проекции точки определяют её положение в пространстве. Так как каждая фигура или тело представляет собой совокупность точек, можно утверждать, что две ортогональные проекции предмета (при наличии буквенных обозначений) вполне определяют его форму.

Однако, в практике изображения строительных конструкций, машин и различных инженерных сооружений возникает необходимость в создании дополнительных проекций. Чтобы сделать проекционный чертеж более ясным и удобочитаемым, используют третью плоскость, перпендикулярную П$_1$ и П$_2$. Эта плоскость обозначается буквой П$_3$  и называется профильной.

Проекции точек на плоскость П$_3$ называются профильными и обозначают А$_3$.

	\begin{wrapfigure}[21]{r!}{0.5\linewidth}
		\includegraphics[width=0.48\textwidth]{Images/ortogonalSystem}
		\caption{Ортогональная система плоскостей.}
		\label{fig:ortSys}
	\end{wrapfigure}
	Плоскости проекций, попарно пересекаясь, определяют три оси: O$_x$, O$_y$ и O$_z$, которые можно рассматривать как систему прямоугольных декартовых координат в пространстве с началом в точке O. Система знаков, соответствующая <<правой системе>> координат, показана на Рис. \ref{fig:ortSys}.

Три плоскости проекций делят пространство на восемь трехгранных углов -- это так называемые октанты. Нумерация октантов дана на Рис. \ref{fig:ortSys}.

Рассматривая ортогональные проекции, предполагают, что наблюдатель находится в первом октанте. Проекционный чертеж, на котором плоскости проекций со всем тем, что на них изображено, совмещены особым образом одна с другой, называется эпюром. Для получения эпюра плоскости П$_1$ и П$_3$ вращают как показано на Рис. \ref{fig:ortSys} до совмещения с плоскостью П$_2$. В результате вращения передняя полуплоскость П$_1$ оказывается совмещенной с нижней полуплоскостью П$_2$, а задняя полуплоскость П$_1$ -- с верхней полуплоскостью П$_2$.

	\begin{wrapfigure}[14]{h}{\linewidth} 
		\includegraphics[width=0.48\textwidth]{Images/complexDraw}
		\caption{Вид совмещённых плоскостей.}
		\label{fig:complDr}
	
	\end{wrapfigure}

	Окончательный вид всех совмещенных плоскостей проекций дан на Рис. \ref{fig:complDr}

\subsection{Три координаты и три проекции точки}
\emph{Координатами} называют числа, которые ставят в соответствие точке для определения ее положения в пространстве или на поверхности.
В трехмерном пространстве положение точки устанавливают с помощью прямоугольных декартовых координат (x, y, z). Абсцисса X определяет расстояние от данной точки до плоскости П$_3$, ордината Y -- до плоскости П$_2$ и аппликата Z -- до плоскости П$_1$. Приняв для отсчета координат точки систему, показанную на Рис. \ref{fig:ortSys} , составим таблицу знаков координат во всех восьми октантах (см. таблицу).
	\begin{tabular}{0,3*\textwidth}{ |c|c|c|c| }
		\hline
	  	Октант & \multicolumn{3}{ |c| }{Знаки координат} \\
	  	\cline{2-4}
	  	& x & y & z\\
	  	\hline
 		 \rom{1} & + & + & +\\
 	  	\hline
 		 \rom{2} & + & - & +\\
 		\hline
 		 \rom{3} & + & - & -\\
 		 \hline
 		 \rom{4} & + & + & -\\	
 		 \hline
 		 \rom{5} & - & + & +\\	
 		 \hline
 		 \rom{6} & - & - & +\\	
 		 \hline
 		 \rom{7} & - & - & -\\	
 		 \hline
 		 \rom{8} & - & + & -\\	
 		 \hline	 
\end{tabular}

Какая-либо точка пространства A, заданная координатами, будет обозначаться так: A(x, y, z). Построение изображения самой точки и ее проекций на пространственной модели рекомендуется осуществлять с помощью координатного прямоугольного параллелепипеда. Прежде всего на осях координат от точки O откладывают отрезки, соответственно равные единицам длины. На этих отрезках (OA$_x$, OA$_y$, OA$_z$), как на ребрах, строят прямоугольный параллелепипед. Вершина его, противоположная началу координат, и будет определять заданную точку A.

Построение параллелепипеда позволяет определить не только точку A, но и все три ее ортогональные проекции.

Лучами, проецирующими точку на плоскости П$_1$, П$_2$ и П$_3$, являются те три ребра параллелепипеда, которые пересекаются в точке A. Каждая из ортогональных проекций точки A, будучи расположенной на плоскости, определяется только двумя координатами. Так, горизонтальная проекция A$_1$ определяется координатами x и y, фронтальная проекция A$_2$ -- координатами x и z, профильная проекция A$_3$ -- координатами y и z. Но две любые проекции определяются тремя координатами. Вот почему задание точки двумя проекциями равносильно заданию точки тремя координатами.

На эпюре (Рис. \ref{fig:complProj}), где все плоскости проекций совмещены, проекции A$_1$ и A$_2$ окажутся на одном перпендикуляре к оси OX, а проекции A$_2$ и A$_3$ -- на одном перпендикуляре к оси Z. 

	\begin{wrapfigure}[16]{h}{0.5\linewidth} 
		\includegraphics[width=0.48\textwidth]{Images/complexProj}
		\caption{Проекции точки (\rom{1} октант) на комплексном чертеже.}
		\label{fig:complProj}
	
	\end{wrapfigure}
	
Что касается проекций A$_1$ и A$_3$, то и они связаны прямыми A$_1$A$_y$ и A$_3$A$_y$, перпендикулярными оси OY. Но так как эта ось на эпюре занимает два положения, то отрезок A$_1$A$_y$ не может быть продолжением отрезка A$3$A$_y$.

Построение проекций точки A на эпюре по заданным координатам выполняют в такой последовательности: прежде всего на оси абсцисс от начала координат откладывают отрезок OA$_x$ = x, а затем через точку A$_x$ проводят перпендикуляр к оси X, на котором с учетом знаков откладываем отрезки A$_x$A$_1$ = y (получаем A$_1$) и A$_x$A$_2$ = z ((получаем A$_2$). Остается построить профильную проекцию точки A$_3$. Так как профильная и фронтальная проекции точки должны быть расположены на одном перпендикуляре к оси Z, то через A$_2$ проводят прямую A$_2$A$_z$.

Наконец, возникает последний вопрос\: на каком расстоянии от оси Z должна находиться A$_3$? Рассматривая координатный параллелепипед (Рис. \ref{fig:ortSys}), ребра которого A$_z$A$_3$ = OA$_y$ = A$_x$A$_1$ = y, заключаем, что искомое расстояние 
A$_z$A$_3$ равно y. Отрезок A$_z$A$_3$ 
откладывают вправо от оси Oz, если y > 0,
 и влево, если y < 0.
 
 \subsection{Структура решения}
 	\begin{enumerate}
 	\item Ввод координат точки пространства и угла между осями координат.
 	\item Перевод трёхмерных координат в координаты экрана. 
 	\begin{itemize}
 		\item Преобразование координат на пространственном чертеже.
 		\item Преобразование координат на комплексном чертеже.
 	\end{itemize}
 	\item Вывод на экран.
 	\begin{itemize}
 		\item Вывод на пространственном чертеже.
 		\item Вывод на комплексном чертеже.
 	\end{itemize}
 	\end{enumerate}
 
 \section{Обзор и анализ методов решения}
 \subsection{Ввод координат точки пространства и угла между осями координат.}
 В программе будет реализовано динамическое изменение координат точки и угла между осями. Современные средства разработки приложений содержат в себе стандартные компоненты, с помощью которых можно обеспечить такую функциональность: переключатели (radiobutton), флажки (checkbox), выпадающие списки, ползунковые переключатели. В рамках данной программы наиболее удобным будет использование ползунковых переключателей.
 \\\\
 \emph{Обобщённый алгоритм}
 	\begin{enumerate}
 		\item Считать значение ползункового переключателя.
 		\item Записать это значение в соответствующую переменную.
 	\end{enumerate}
\subsection{Перевод трёхмерных координат в координаты экрана.}

Для построения чертежей на экране необходимо перевести координаты из реальной трёхмерной системы координат в двумерную систему координат экрана (для пространственного макета), а также определить по трёхмерных координатам координаты на комплексном чертеже и перевести их в двумерную систему координат экрана.

\subsubsection{Для пространственного чертежа}
Необходимо преобразовать трехмерную систему координат и точку в ней в двумерную систему координат экрана, вычислить координаты проекций точки и линий связи.
Входные данные:	
 	\begin{itemize}
 		\item (x, y, z) - координаты точки в трёхмерном пространстве.
 		\item $\alpha$ - значение угла между отрицательным направлением оси OX и положительным направлением оси OY.
 	\end{itemize}
 Выходные данные:	
 	\begin{itemize}
 		\item экранные координаты точек системы координат.
 		\item экранные координаты точки Т(x$_t$,y$_t$)
 		\item экранные координаты точек проекций T$_1$, T$_2$, T$_3$ на плоскости П$_1$, П$_2$ и П$_t3$ соответственно.
 		\item экранные координаты точек T$_x$, T$_y$, T$_z$ на осях X, Y и Z соответственно.
 	\end{itemize}
Чтобы изобразить пространственный чертеж, необходимо провести преобразования трёхмерных координат в двумерную систему координат экрана.  (Рис. \ref{fig:screenCoordSys}). \hspace*{\fill}
	\begin{wrapfigure}[13]{h}{0.5\linewidth} 
		\includegraphics[width=0.48\textwidth]{Images/screenCoordinateSystem}
		\caption{Экранная система координат.}
		\label{fig:screenCoordSys}
	
	\end{wrapfigure}
	
Для удобства пользователя логично расположить начало координат в центре экрана.
Координаты центра вычислим по формулам:
\\\\
x$_0$ = $\frac{width}{2}$
\\
y$_0$ = $\frac{heigth}{2}$,\\
где \emph{width} и \emph{height} -- ширина и высота экрана соответственно.

Таким образом, нужно вывести формулы для перевода заданных трёхмерных координат произвольной точки T(x, y, z) в двумерные координаты экрана (обозначим их как x$_t$ и y$_t$), учитывая заданный угол между отрицательным направлением оси X и положительным направлением оси Y и заданное выше начало координат.

	\begin{wrapfigure}[18]{r}{0.7\linewidth} 
		\includegraphics[width=0.67\textwidth]{Images/pointOnCoordinates}
		\caption{}%todo
		\label{fig:pointOnCoords}
	\end{wrapfigure}
	
Из рисунка \ref{fig:pointOnCoords} видно, что:
\\
	x$_t$ = x$_0$ - x + dx, \\
	y$_t$ = y$_0$ - z + dy, \\
	dx = y*cos($\alpha$), dy = y*sin($\alpha$)

	Отсюда:
\\
	x$_t$ = x$_0$ -x + y*cos($\alpha$) (1)\\
	y$_t$ = y$_0$-z+y*sin($\alpha$) (2)\\
	
Таким образом, мы получили формулы для вычисления экранных координат произвольной точки трёхмерного пространства по заданным трёхмерным координатам, углу angle (углу между отрицательным направлением оси OX и положительным направлением оси OY) и началу координат.
	
	Также мы можем вычислить экранные координаты для всех точек пространственного чертежа:
	\\
	O ($\frac{width}{2}$, $\frac{height}{2}$) (2)\\
	T$_x$ (x$_0$, y$_0$) (3)\\
	T$_y$ (x$_0$ - y*cos($\alpha$), y$_0$ + y*sin($\alpha$)) (4)\\
	T$_z$ (x$_0$, y$_0$ - z) (5)\\
	T$_1$ (x$_0$ - x + y*cos($\alpha$), y$_0$ + y*sin($\alpha$))\\
	T$_2$ (x$_0$ - x, y$_0$ - z)\\
	T$_3$ (x$_0$ + y*cos($\alpha$), y$_0$ - z + y*sin($\alpha$))\\
	T (x$_0$ - x + y*cos($\alpha$), y$_0$ - z + y*sin($\alpha$))
	
	Заметим, что получив координаты точек T$_x$, T$_y$ и  T$_z$ можно использовать эти значения для вычисления точек T, T$_1$, T$_2$ и T$_3$. Таким образом:\\
	T$_1$ (T$_y$.x - x, T$_y$.y)	(6)\\
	T$_2$ (T$_x$.x, T$_z$.y)	(7)\\
	T$_3$ (T$_y$.x, T$_y$.y - z)	(8)\\
	T (T$_1$.x, T$_3$.y)		(9)
	\\
	
\emph{Обобщенный алгоритм:}
Используя формулы 1-9 найти:
	\begin{itemize}
		\item экранные координаты начала отсчёта пространственного макета.
		\item экранные координаты точек начала и конца осей системы координат.
		\item экранные координаты точки T.
		\item экранные координаты её проекций на плоскости П$_1$, П$_2$, П$_3$ — точки Т$_1$, Т$_2$ и Т$_3$ соответственно.
		\item экранные координаты её проекций на координатные оси — точки T$_x$, T$_y$, T$_z$.
	\end{itemize}

\subsubsection{Для комплексного чертежа}
Входные данные:
	\begin{itemize}
		\item координаты точки T в трёхмерном пространстве.
	\end{itemize}
	
Выходные данные:
	
	\begin{itemize}
		\item комплексный чертеж.
	\end{itemize}
	
Центр координат расположим также в центре экрана. Координаты центры находятся как:\\\\
x$_0$ = $\frac{width}{2}$
\\
y$_0$ = $\frac{heigth}{2}$,\\
где \emph{width} и \emph{height} -- ширина и высота экрана соответственно.

	\begin{wrapfigure}[20]{r!}{0.7\linewidth} 
		\includegraphics[width=0.67\textwidth]{Images/complexDrawingPrototype}
		\caption{Прототип комплексного чертежа}
		\label{fig:complDrawProto}
	\end{wrapfigure}

Из рисунка \ref{fig:complDrawProto} можно найти координаты всех точек комплексного чертежа:\\
	O (x$_0$, y$_0$) (10)\\
	T$_x$ (x$_0$ - x, y$_0$) (11)\\
	T$_z$ (x$_0$, y$_0$ - z) (12)\\
	T$_y1$ (x$_0$ + y, y$_0$) (13)\\
	T$_y2$ (x$_1$, y$_0$ + y) (14)\\
	T$_1$ (x$_0$ - x, y$_0$ + y)\\
	T$_2$ (x$_0$ - x, y$_0$ - z)\\
	T$_3$ (x$_0$ + y, y$_0$ - z)
	
Зная координаты точек T$_x$,T$_y1$,T$_y2$ и  T$_z$ можно вычислить значения координат точек  T$_1$, T$_2$ и T$_3$:\\
	T$_1$ (T$_x$.x, T$_y2$.y) (15)\\
	T$_2$ (T$_x$.x, T$_z$.y) (16)\\
	T$_3$ (T$_y1$.x, T$_z$.y) (17)\\
	
\emph{Обобщённый алгоритм:}
Используя формулы 10-17, найти:
	\begin{itemize}
		\item экранные координаты точки начала отсчета комплексного чертежа.
		\item экранные координаты точек начала и конца осей системы координат.
		\item экранные координаты точки T.
		\item Экранные координаты проекций точки Т на плоскости П$_1$, П$_2$ и П$_3$ — точки Т$_1$, Т$_2$ и Т$_3$ соответственно.
		\item Экранные координаты проекций точки Т на оси X, Z и Y — точки T$_x$, T$_z$ и T$_y1$, T$_y2$.
	\end{itemize}
	
\section{Отрисовка (вывод чертежей на экран).}
Для отрисовки чертежей нужно отрисовывать следующие примитивы: линия, окружность и точка. Это можно сделать с помощью стандартных функций.

В \textbf{ОС Windows} для того, чтобы вывести необходимое изображение на устройство вывода (экран, принтер и т. д.) довольно часто используется Интерфейс Графических Устройств GDI (Graphical Device Interface), представляющий собой интерфейс, который Windows использует для рисования 2D графики. Когда приложения обращаются к GDI для вывода графического изображения, они работают не с реальными (физическими) устройствами, а с логическими. Приложения Windows не определяют тип видеомонитора,а работают с логическим видеомонитором. Выполняя запрос приложения, GDI обращается к драйверу соответствующего устройства вывода, а драйвер работает непосредственно с физическим устройством вывода. За счёт этого, в процессе выполнения запроса GDI (или драйвер) учитывает ограниченные возможности физического устройства вывода и его аппаратные особенности, делая необходимые приближения. 

В \textbf{UNIX-подобных} системах для вывода графики почти повсеместно используется X Window System. Она берет на себя заботы о вводе и выводе на низком уровне, предоставляя пользовательским программам работать в терминах оконного интерфейса. X Window System использует традиционную оконную модель, в которой пространством ресурсов является экран. Экран — это прямоугольник, на котором отображаются команды графического вывода и организуется обратная связь с устройствами графического ввода. Программа, которая отвечает за работу с устройствами графического ввода и вывода и обеспечивает при этом логику оконной системы, называется X-сервером. В рамках X Window System, X-сервер — это ядро. Он выполняет низкоуровневые операции и взаимодействует с аппаратурой, ничего самостоятельно не предпринимая. Подобно ядру, он предоставляет задачам унифицированный интерфейс к этим низкоуровневым функциям, а также занимается разделением доступа (окно и фокус) к графическим ресурсам. X-сервер не волнует, отчего эти задачи вообще появляются и чем живут. Он только принимает запросы на выполнение графических действий и передаёт по назначению вводимые данные. Жизнеобеспечение процессов и даже способ передачи X-запросов — дело исключительно операционной системы, по отношению к которой и сам X-сервер — задача.

Задачи, которые обращаются к X-серверу с запросами, называются X-клиентами. Обычно X-клиент сначала регистрирует окно (можно несколько), которое и будет ему полем ввода-вывода. Потом он сможет рисовать в этом окне и обрабатывать происходящие с окном события: активность устройств ввода и изменение свойств самого окна (размер, перемещение, превращение в иконку, закрытие и т. п.). X-клиент в Linux — это процесс, запускаемый обычно в фоне не связанный по вводу с терминальной линией). 

\subsection{Обобщённый алгоритм}
Для изображения пространственного чертежа требуется:

	\begin{itemize}
		\item Прорисовать оси координат и подписать их.
		\item Прорисовать точки и её проекции на плоскости и оси, подписать точки.
		\item Прорисовать линии связи.
		\item Для изображения пространственного чертежа требуется:
		\item Прорисовать оси координат и подписать их.
		\item Прорисовать точки и её проекции на плоскости и оси, подписать точки.
		\item Прорисовать линии связи проекции.
	\end{itemize}
	
\subsection{Описание и реализация применяемых методов}
Координаты точек и функции по вычислению их значения выделены в классы DimensionalDrawing для пространственного чертежа и ComplexDrawing для комплексного чертежа. Координаты точек хранятся в виде экзмепляров класса QPoint, атрибутами которого являются значения x и y.

\subsubsection{Ввод координат точки пространства и угла между осями}
Для ввода координат и угла между осями используются виджеты типа QSlider. Для каждого из них определяется диапазон значений и значение инкремента.
\lstset {language=C++}
\begin{lstlisting}
sliderX.setRange(-120, 120)
sliderY.setRange(-120, 120)
sliderZ.setRange(-120, 120)
sliderX.setAlpha(-15, 75)
\end{lstlisting}
\subsubsection{Вычисления. Укрупненный алгоритм}
\emph{Для пространственного чертежа}:

Необходимо преобразовать трехмерную систему координат и точку в ней в двумерную систему координат экрана, вычислить координаты проекций точки и линий связи.

	\begin{itemize}
		\item width -- ширина области чертежа.
		\item height — высота области чертежа.
		\item indent -- отступ от края чертежа.
		\item O (x$_0$, y$_0$) -- точка начала координат.
		\item angle -- угол между положительным направлением оси Y и отрицательным направлением оси X.
		\item OX\_begin, OX\_end, OY\_begin, OY\_end, OZ\_begin, OZ\_end — начальные и конечные точки осей координат.
		\item x, y, z -- координаты точки Т в трёхмерном пространстве.
	\end{itemize}
	
\textbf{Алгоритм:}

Используя формулы 1-9, найдем:

	\begin{itemize}
		\item Экранные координаты начальных и конечных точек осей OX, OY и OZ.
To(x0, y0) (2) — точка начала координат.
OX\_begin(x,y), OX\_end(x,y) -- крайние точки оси OX.OY\_begin(x,y), OY\_end(x,y) -- крайние точки оси OY. OZ\_begin(x,y), OZ\_end(x,y) -- крайние точки оси OZ.
		\item Экранные координаты проекций точки Т на координатные оси.\\
Т$_x$ (x, y) -- проекция на ось X. (3)\\
T$_y$ (x, y) -- проекция на ось Y. (4)\\
T$_z$ (x, y) -- проекция на ось Z. (5)\\
		\item Экранные координаты точки T. T(X$_t$, Y$_t$) (9)
		\item Экранные координаты проекций точки Т на плоскости П1, П2 и П3.\\
T$_1$ (x,y) -- проекция на плоскость П$_1$. (6)\\
T$_2$ (x,y) -- проекция на плоскость П$_2$. (7)\\
Т$_3$ (x,y) -- проекция на плоскость П$_3$. (8)

	\end{itemize}
	
	\emph{Для комплексного чертежа:}
	
	\begin{itemize}
		\item width -- ширина чертежа.
		\item height -- высота чертежа.
		\item indent -- отступ от границы чертежа.  

	\end{itemize}
	
\textbf{Алгоритм:}

Используя формулы 10-17 найдем:
	\begin{itemize}
		\item Экранные координаты центра координат.\\
O (x$_0$,y$_0$) -- центр координат (10)
		\item Экранные координаты начальных и конечных точек осей XY и ZY.
	XY\_begin(x,y), XY\_end(x,y) -- крайние точки оси XY.
	ZY\_begin(x,y), ZY\_end(x,y) -- крайние точки оси ZY.
		\item Экранные координаты проекций точки Т на координатные оси.\\
	T$_x$ (x, y) -- проекция на ось OX. (11)\\
	T$_z$ (x, y) -- проекция на ось OZ. (12)\\
	T$_y1$ (x, y) -- проекция на ось OY. (13)\\
	T$_y2$ (x, y) -- проекция на ось OY. (14)  
		\item Экранные координаты проекций точки Т на плоскости П$_1$, П$_2$ и П$_3$.\\
	T$_1$ (x, y) — проекция на плоскость П$_1$. (15)\\
	Т$_2$ (x, y) — проекция на плоскость П$_2$. (16)\\
	Т$_3$ (x, y) — проекция на плоскость П$_3$. (17)\\
	\end{itemize}
	
	
\subsection{Прорисовка. Укрупненный алгоритм}
\subsubsection{Отрисовка пространственного чертежа. Укрупненный алгоритм}
\textbf{Прорисовка осей}

Чтобы нарисовать оси системы координат, необходимо соединить линиями точки OX\_begin -- OX\_end, OY\_begin -- OY\_end, OZ\_begin -- OZ\_end. Отрисовка оси производится с помощью функции QPainter::drawLine(). Подпись осей с помощью функции QPainter::drawText().\\
\\
\textbf{Прорисовка точек}

Точки Т, Т$_1$, Т$_2$, Т$_3$, T$_x$, T$_y$, T$_z$ отрисовываются с помощью функции QPainter::drawEllipce(). Подпись точек производится с помощью функции QPainter::drawText().\\
\\
\textbf{Прорисовка линий связи}

Чтобы отрисовать линии связи, необходимо соединить линиями точки T$_1$-T$_x$, T$_1$,-T, T-T$_2$, T$_2$-T$_x$, T$_2$-T$_z$, T-T$_3$, T$_1$-T$_y$, T$_z$-T$_3$, T$_3$-T$_y$. Линии рисуются с помощью функции QPainter::drawLine().

\subsubsection{Отрисовка комплексного чертежа. Укрупненный алгоритм}
\textbf{Прорисовка осей}

Чтобы нарисовать оси, наобходимо соединить линиями точки XY\_begin -- XY\_end и ZY\_begin -- ZY\_end. Отрисовка оси производится с помощью функции QPainter::drawLine(). Подпись осей с помощью функции QPainter::drawText().\\
\\
\textbf{Прорисовка точек}

Точки T$_1$, T$_2$, T$_3$, T$_x$, T$_y1$, T$_y2$, T$_z$ отрисовываются с помощью функции QPainter::drawEllipce(). Подпись точек производится с помошью функции QPainter::drawText().\\
\\
\textbf{Прорисовка линий связи}

Чтобы отрисовать линии связи необходимо соединить линиями точки T$_y1$-T$_1$, T$_1$-T$_x$, T$_x$-T$_2$, T$_2$-T$_z$, T$_z$-T$_3$, T$_3$-T$_y1$ и отрисовать дугу T$_y1$-T$_y2$. Линии отрисовываются с помощью функции QPainter::drawLine(), а дуга -- функцией QPainter::drawArc().

\subsection{Вычисления. Детализированный алгоритм}
\subsubsection{Пространственный чертеж}

Разобём задачу перевода координат в координаты экрана на две части -- сначала, в контроллере, вычислим значение точки в координатах экрана, а затем, в виджете пространственного чертежа, перенесём эти координаты в координаты относительно точки О.

\emph{Функция для вычисления значения точки в координатах экрана:}
\lstset {language=C++}
\begin{lstlisting}
QPoint Controller::point(){
    int x = _point.x();
    int y = _point.y();
    int z = _point.z();

    x = (x) - z * cos(_alpha * M_PI/180);
    y = y - z * sin(_alpha * M_PI/180);

    return QPoint(-x, y);
}
\end{lstlisting}
\emph{Перевод координат точки в координаты относительно точки О:}
\begin{lstlisting}
void DimensionalDrawing::translateToNativeCoords(QPoint &p){
    p.setY(-p.y());
    p += QPoint(this->width() / 2, this->height() / 2);
}
\end{lstlisting}
\emph{Перевод координат линии в координаты относительно точки O:}
\begin{lstlisting}
void DimensionalDrawing::translateToNativeCoords(QLine& l){

    QPoint p1 = l.p1();
    QPoint p2 = l.p2();

    auto tempY = p1.y();

    p1.setY(p2.y());
    p2.setY(tempY);

    l.setPoints(p1, p2);
    l.translate(this->width() / 2, this->height() / 2);
}
\end{lstlisting}

Координаты вспомогательных точек Т$_1$, Т$_2$, Т$_3$, T$_x$, T$_y$, T$_z$ вычисляются в функции:
\begin{lstlisting}
QHash<QString, QPoint> Controller::dimensionalDravingPoints(){
    QPoint tx, ty, tz, xy, yz, xz;

    tx = QPoint(-_point.x(), 0);
    ty = QPoint(0, _point.y());
    tz = QPoint(
           _point.z() * cos(_alpha * M_PI/180),
          -_point.z() * sin(_alpha * M_PI/180)
                );

    xy = QPoint(-_point.x(), _point.y());

    yz = QPoint(
                _point.z() * cos(_alpha * M_PI/180),
                _point.y() - _point.z() * sin(_alpha * M_PI/180)
                );

    xz = QPoint(
                -(_point.x() - _point.z() * cos(_alpha * M_PI/180)),
                - _point.z() * sin(_alpha * M_PI/180)
            );

    QHash<QString, QPoint> points = {
        {"Tx", tx},
        {"Ty", ty},
        {"Tz", tz},
        {"Txy", xy},
        {"Txz", xz},
        {"Tyz", yz}
    };

    return points;
\end{lstlisting}
И переводятся в координаты чертежа с помощью функции
\\
translateToNativeCoords(QPoint\& ).

\subsubsection{Комплексный чертеж}
Разобём задачу перевода координат в координаты экрана на две части -- сначала, в контроллере, вычислим значение точки в координатах экрана, а затем, в виджете пространственного чертежа, перенесём эти координаты в координаты относительно точки О.

\emph{Функция для вычисления значения точкек  точек T, Т$_1$, Т$_2$, Т$_3$, T$_x$, T$_y$, T$_z$ в координатах экрана:}
\lstset {language=C++}
\begin{lstlisting}
QHash<QString, QPoint> Controller::complexDravingPoints(){
    QPoint tx, ty1, ty2, tz, t1, t2, t3;

    tx = QPoint(- _point.x(), 0);

    tz = QPoint(0, _point.z());

    ty1 = QPoint(_point.y(), 0);
    ty2 = QPoint(0, -_point.y());

    t1 = QPoint(tx.x(), ty2.y());
    t2 = QPoint(tx.x(), tz.y());
    t3 = QPoint(ty1.x(), tz.y());

    QHash<QString, QPoint> points = {
        {"T1", t1},
        {"T2", t2},
        {"T3", t3},
        {"Tx", tx},
        {"Tz", tz},
        {"Ty1", ty1},
        {"Ty2", ty2}
    };
    return points;
}
\end{lstlisting}
\emph{Перевод координат точки в координаты относительно точки О:}
\begin{lstlisting}
void DimensionalDrawing::translateToNativeCoords(QPoint &p){
    p.setY(-p.y());
    p += QPoint(this->width() / 2, this->height() / 2);
}
\end{lstlisting}
\emph{Перевод координат линии в координаты относительно точки O:}
\begin{lstlisting}
void DimensionalDrawing::translateToNativeCoords(QLine& l){

    QPoint p1 = l.p1();
    QPoint p2 = l.p2();

    auto tempY = p1.y();

    p1.setY(p2.y());
    p2.setY(tempY);

    l.setPoints(p1, p2);
    l.translate(this->width() / 2, this->height() / 2);
}
\end{lstlisting}
\subsection{Прорисовка. Детализированный алгоритм}
\subsubsection{Пространственный чертеж}
Прорисовка происходит в функции:
\begin{lstlisting}
void DimensionalDrawing::paintEvent(QPaintEvent *){
    QPainter paint(this);
    QPen pen;
    QBrush brush(QColor(255,235,153, 255));
    paint.setBrush(brush);
    pen.setColor(QColor(20,10,70,255));
    paint.drawRect(0,0,this->width(),this->height());

    pen.setColor(QColor(0,0,0,255));
    paint.setPen(pen);

    QLine x = _coordinateAxes.value("X");
    this->translateToNativeCoords(x);
    paint.drawLine(x);
    paint.drawText(x.p1(), "X");


    QLine y = _coordinateAxes.value("Y");
    this->translateToNativeCoords(y);
    paint.drawLine(y);
    paint.drawText(y.p1(), "Y");

    QLine z = _coordinateAxes.value("Z");
    this->translateToNativeCoords(z);
    paint.drawLine(z);
    paint.drawText(z.p1(), "Z");

    QPoint t = _point;
    this->translateToNativeCoords(t);

    paint.drawText(t, "T");

    QPoint zero(0,0);
    this->translateToNativeCoords(zero);
    paint.drawEllipse(zero, 2, 2);
    zero += QPoint(10, -10);
    paint.drawText(zero, "0");

    QPoint tx, ty, tz, xy, xz, yz;
    QVector<QPoint*> points;
    tx = _helperPoints.value("Tx");
    ty = _helperPoints.value("Ty");
    tz = _helperPoints.value("Tz");

    xy = _helperPoints.value("Txy");
    xz = _helperPoints.value("Txz");
    yz = _helperPoints.value("Tyz");

    points << &tx << &ty << &tz << &xy << &xz << &yz;

    for(auto& x : points){
        this->translateToNativeCoords(*x);
        paint.drawEllipse(*x, 1, 1);
    }

    pen.setStyle(Qt::DashLine);
    pen.setColor(QColor(125, 127, 125, 255));
    paint.setPen(pen);

    paint.drawLine(t, xz);
    paint.drawLine(t, yz);
    paint.drawLine(t, xy);

    paint.drawLine(tx, xy);
    paint.drawLine(tx, xz);

    paint.drawLine(ty, yz);
    paint.drawLine(ty, xy);

    paint.drawLine(tz, xz);
    paint.drawLine(tz, yz);

    brush.setStyle(Qt::Dense1Pattern);
    pen.setColor(QColor(128, 0, 255, 255));
    pen.setWidth(2);
    paint.setPen(pen);

    paint.drawEllipse(t, 2, 2);

}
\end{lstlisting}
\subsubsection{Комплексный чертеж}
Прорисовка происходит в функции:
\begin{lstlisting}
void ComplexDrawing::paintEvent(QPaintEvent *){
    QPainter paint(this);
    QPen pen;
    QBrush brush(QColor(135,206,235, 255));
    paint.setBrush(brush);
    pen.setColor(QColor(20,10,70,255));
    paint.drawRect(0,0,this->width(),this->height());

    int size = this->width() / 2 - 20;
    QLine x, y;
    //y
    y.setP1(QPoint(0, size));
    y.setP2(QPoint(0, -size));

    //x
    x.setP1(QPoint( -size, 0));
    x.setP2(QPoint(size, 0));

    this->translateToNativeCoords(x);
    this->translateToNativeCoords(y);

    paint.drawLine(x);
    paint.drawLine(y);
    paint.drawText(y.p1(), "Z");
    paint.drawText(x.p1(), "X");
    paint.drawText(x.p2(), "Y");
    paint.drawText(y.p2(), "Y");

    for(auto&p : _points){
        this->translateToNativeCoords(p);
        paint.drawEllipse(p, 2, 2);
    }

    QPoint t1 = _points.value("T1");
    paint.drawText(t1, "T1");

    QPoint t2 = _points.value("T2");
    paint.drawText(t2, "T2");

    QPoint t3 = _points.value("T3");
    paint.drawText(t3, "T3");

    QLine line(t1, t2);
    paint.drawLine(line);

    line.setPoints(t2,t3);
    paint.drawLine(line);

    QPoint zero(0,0);
    this->translateToNativeCoords(zero);
    paint.drawEllipse(zero, 1, 1);

    QPoint ty1 = _points.value("Ty1");
    QPoint ty2 = _points.value("Ty2");

    QSize area((ty1.x() - zero.x())*2, (ty2.y() - zero.y())*2);

    int delta = ty1.x() - zero.x();

    QPoint areaPoint(zero.x() - delta, zero.y() - delta);

    int startAngle = zero.x() > ty1.x() ? 90*16 : 0;
    int spainAngle = zero.x() > ty1.x() ? 90*16 : -90*16;

    paint.drawArc(QRect(areaPoint, area), startAngle, spainAngle);

    zero += QPoint(10, -10);
    paint.drawText(zero, "0");

    pen.setStyle(Qt::DashLine);
    paint.setPen(pen);

    paint.drawLine(t1, ty2);
    paint.drawLine(t3, ty1);

}

\end{lstlisting}
\section{Руководство программиста}
Программа написана на языке C++14 с использованием кроссплатформенной библиотеки Qt. Изображения выводятся на виджетах ComplexDrawing и DimensionalDrawing. Ввод данных осуществляется с помощью ползунковых переключателей QSlider. Для отображения текста используется виджет QLabel.
	
Виджеты QSlider:
\begin{itemize}
	\item sliderX -- изменяет координату x.
	\item sliderY -- изменяет координату y.
	\item sliderZ -- изменяет координату z.
	\item sliderAlpha -- изменяет угол $\alpha$.
\end{itemize}

\subsection{Функциональная схема программы (Рис. \ref{fig:classDyagr})}

	\begin{figure}[h]
		\center{\includegraphics[width=\textwidth]{Images/classDyagram}}
		\caption{Функциональная схема программы}
		\label{fig:classDyagr}
	
	\end{figure}
	
В программе используется пять классов
\begin{enumerate}
	\item Point -- класс, хранящий координаты 3D точки. В нем имеются только 3 атрибута:
		\begin{itemize}
			\item x -- координата по оси x
			\item y -- координата по оси y
			\item z -- координата по оси z
		\end{itemize}
	\item MainWindow --  класс, реализующий основную форму программы. В нем происходит инициализация других виджетов и установка их параметров.
	\item DimensionalDrawing -- класс, описывающий пространственный чертеж. Хранит информацию о всех точках пространсвенного чертежа и линиях координат.
	\item ComplexDrawing -- класс, описывающий комплексный чертеж. Хранит информацию о всех точках комплексного чертежа и линиях координат. 
	\item Controller -- класс, инициализирующий MainWindow, хранящий информацию о координатах точки (в Point). Controller реализует методы пересчета координат точек для пространственного и комплексного чертежей.
\end{enumerate}

При запуске программы создаётся экземпляр класса Controller, котрый создаёт экземпляр класса MainWindow:
\begin{lstlisting}

int Controller::init(int argc, char *argv[]){
    QApplication a(argc, argv);
    Controller::_mainWindow = new MainWindow();
    _mainWindow->show();
    return a.exec();
}
\end{lstlisting}

\section{Руководство пользователя}
	\begin{figure}[h]
		\center{\includegraphics[width=\textwidth]{Images/ApplicationScreen}}
		\caption{Вид приложения}
		\label{fig:appScr}
	
	\end{figure}
После запуска программы пользователь видит в окне программы два поля: в левом рисуется пространственный чертеж, а в правом -- комплексный чертеж. Изменяя положение ползунков в нижней части окна, пользователь может изменять координаты точки в пространстве и угол между отрицательным направлением оси X и положительным направлением оси Z. Окно приложения представленно на Рис. \ref{fig:appScr}.
 \end{document}
