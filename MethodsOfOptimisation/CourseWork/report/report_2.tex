\documentclass[14pt,a4paper]{extarticle}
\usepackage[left=3cm,right=1cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[final]{graphicx}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{tabulary}
\usepackage{placeins}
\usepackage{needspace}
\usepackage{color}
\usepackage[cache=false]{minted}
\usepackage{listings}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

\renewcommand{\thesection}{}
\renewcommand*\thesubsection{\arabic{subsection}.}
\renewcommand*\thesubsubsection{\arabic{subsection}.\arabic{subsubsection}}

\graphicspath{{Images/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg,.svg}

\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\asbuk{enumii})}


\author{Пахтусов Н. Г., ПРО-306}
\makeatletter
\begin{document}

\begin{center}
\thispagestyle{empty} 

Федеральное государственное бюджетное образовательное учереждение высшего \\
профессионального образования\\
<<Уфимский государственный авиационный технический университет>>
\vspace*{\fill}
\begingroup
\centering

Пояснительная записка к курсовой работе\\
по дисциплине: <<Методы Оптимизации>>\\
на тему: <<Задача о рюкзаке: Задача об отправке грузов>>.

\endgroup
\vspace*{\fill}

\end{center}

\begin{flushright}

Выполнил:\\
\@author \\
Проверила: \\
Валеева А. Ф.

\end{flushright}

\begin{center}
Уфа, 2015 г.
\end{center}

\clearpage
\tableofcontents
\clearpage

\section{Введение}

	Для множества задач в прикладной математике нахождение решения прямым перебором за приемлимое время невозможно. К таким задачам относится, например, класс NP-полных задач.
	
	Одной из задач этого класса является так называемая <<Задача о рюкзаке>>. Задача о рюкзаке -- одна из NP-задач комбинаторной оптимизации. Своё название она получила от максимизационной задачи укладки как можно большего числа ценных вещей в рюкзак при условии, что вместимость рюкзака ограничена. С различными вариациями задачи о ранце можно столкнуться в экономике, прикладной математике, криптографии, генетике и логистике.
	
	В работе рассмативется одна из разновидностей этой задачи -- <<Задача об отправке грузов>>. 

\subsection{Постановка задачи}

	Пусть существует некоторое \emph{количество} авиалайнеров и некоторое \emph{количество} контейнеров. У каждого контейнера есть свой \emph{вес}, а у авиалайнеров есть \emph{ограничение по суммарному весу} контейнеров.
	
	Пусть также различна \emph{выгода} от отправки различными авиалайнерами одного и того же контейнера.
	
	Задача состоит в том, чтобы перевезти контейнеры на авиалайнерах с \emph{максимальной выгодой}. 

\subsection{Математическая модель}

	Пусть $I = \{1,\cdots, n\}$ -- авиалайнеры, $J = \{1,\cdots, m\}$ -- контейнеры.
	
	$p_{ij}$ -- доход от доставки авиалайнером i контейнера j.
	
	$w_{j}$ -- вес контейнера j.
	
	$c_{i}$ -- вместимость авиалайнера i.
	
	$x_{ij} \in \{0,1\}$ -- количество контейнеров j в авиалайнере i.
	\\
	Таким образом, необходимо найти:
	
	$\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{m}p_{ij}x_{ij} \to max$
	\\
	При ограничениях: 
	
	$\sum\limits_{i=0}^{n}x_{ij} \le 1, j \in J$
	
	
	$\sum\limits_{j=0}^{m}w_{j}x_{ij} \le c_{i}, i \in I$.[2]
	
	
\subsection{Методы решения задачи}

	Для решения задач о рюкзаке используется несколько различных эвристических и оптимизационных. Рассмотрим некоторые из них.
	
	\subsubsection{Полный перебор}
	
		Временная сложность алгоритма O(N!), т.е он работоспособен для небольших значений N. С ростом N задача становится неразрешимой данным методом за приемлемое время.
	
	\subsubsection{Метод ветвей и границ}
	
		Метод ветвей и границ (англ. \emph{branch and bound}) -- общий алгоритмический метод для нахождения оптимальных решений различных задач оптимизации, особенно дискретной и комбинаторной оптимизации. По существу, метод является вариацией полного перебора с отсевом подмножеств допустимых решений, заведомо не содержащих оптимальных решений.

		Общая идея метода может быть описана на примере поиска минимума функции \texttt{f(x)} на множестве допустимых значений переменной \texttt{x}. Функция \texttt{f} и переменная x могут быть произвольной природы. Для метода ветвей и границ необходимы две процедуры: ветвление и нахождение оценок (границ).

		Процедура ветвления состоит в разбиении множества допустимых значений переменной x на подобласти (подмножества) меньших размеров. Процедуру можно рекурсивно применять к подобластям. Полученные подобласти образуют дерево, называемое деревом поиска или деревом ветвей и границ. Узлами этого дерева являются построенные подобласти (подмножества множества значений переменной \texttt{x}).

		Процедура нахождения оценок заключается в поиске верхних и нижних границ для решения задачи на подобласти допустимых значений переменной \texttt{x}.

		В основе метода ветвей и границ лежит следующая идея: если нижняя граница значений функции на подобласти \texttt{A} дерева поиска больше, чем верхняя граница на какой-либо ранее просмотренной подобласти \texttt{B}, то \texttt{A} может быть исключена из дальнейшего рассмотрения (правило отсева).

		Если нижняя граница для узла дерева совпадает с верхней границей, то это значение является минимумом функции и достигается на соответствующей подобласти.


	\subsubsection{Жадный алгоритм}
	
	В жадном алгоритме (greedy algorithm) всегда делается выбор, который кажется самым лучшим в данный момент -- т.е. производится локально оптимальный выбор в надежде, что он приведет к оптимальному решению глобальной задачи[3].
	
	Согласно жадному алгоритму предметы сортируются по убыванию стоимости единицы веса каждого. В рюкзак последовательно складываются самые дорогие за единицу веса предметы из тех, что помещаются внутри.
	
	Сложность сортировки предметов $O(N\log_2(N))$. Далее происходит перебор всех \texttt{N} элементов.
	
	Жадный алгортим является эвристическим, таким образом, точное решение можно получить не всегда (жадный алгоритм всегда даёт точное решение, если структура задачи задается матроидом: тогда применение жадного алгоритма выдаст глобальный оптимум, однако наша задача к ним не отностится)[1].
	
	%\subsubsection{Генетический алгоритм}
	
	%Содержимое рюкзака представляется в виде хромосом или бинарных строк, i-й бит которых равен единице в случае наличия предмета в рюкзаке, нулю -- в случае его отсутствия. Задается целевая функция S -- вместимость рюкзака.
	
	%Отбор осуществляется следующим образом.
	
	%Выбирается произвольная хромосома. Пусть $L_{max} = max(S, S'' - S)$ максимальное расхождение между целевой функцией и хромосомой. $S''$ суммарный вес всех предметов, входящих в рюкзачный вектор. $S'$ -- вес рюкзака при выбранной хромосоме.
	
	%Если $S' \le S$, о хромосома оценивается числом 
	
	%$q = 1 - \sqrt{\frac{|S' - S|}{S}}$
	
	%Иначе:
	
	%$q = 1 - \sqrt{\frac{|S' - S|}{L_{max}}}$
	
	%По этому числу осуществляется отбор хромосом.
	
	%Алгоритм прерывается после заданного числа итераций.

	%Генетический алгоритм не гарантирует нахождения оптимального решения, однако показывает хорошие результаты за меньшее время по сравнению с другими алгоритмами.

\subsection{Алгоритм решения задачи}

	Для решения задачи был выбран <<\textbf{Жадный алгоритм}>>.
	
	Входные данные: на вход алгоритму подаётся массив значений весов грузов $w_j  j \in \{1\dots J\}$, массив вместимости контейнеров $c_i, i \in \{1\dots I\}$ и матрица стоимости $I \times J$.
	
	Выходные данные: общая стоимость всех выбранных грузов.
	
	Введём некоторые структуры данных, которые будут использоваться в алгоритме:
	\begin{itemize}
		\item \texttt{Cargo} -- структура, использующаяся для представления одного груза, с двумя полями: 
			\begin{enumerate}
				\item Поле \texttt{is\_used} $\in$ \{1, 0\}, изначально значение = 0, если предмет уже был обработан, значение изменяется на 1.
				\item Вес предмета $w_j$.
			\end{enumerate}
		\item \texttt{Knapsack} -- структура, использующаяся для представления одного вместилища, с полями:
			\begin{enumerate}
				\item Поле-список, хранящий некоторые значения $j \in J$ и означающим то, что $j$ предмет лежит в данном вместилище.
				\item Поле-значение, означающее максимальный возможный вес для этого контейнера $c_i$.
			\end{enumerate}
		\item \texttt{Cost} -- структура, использующаяся для хранения стоимости. Она хранит следующие значения: $i \in I$ и $j \in J$, которые означают i вместилище и j груз, а также выгоду отправки $p_{ij}$.
	\end{itemize}
	
	Таким образом, алгоритм будет состоять из следующих шагов:
	\begin{enumerate}
		\item Сформировать из входных данных массивы структур \texttt{Cargo}, \texttt{Knapsack} и \texttt{Cost} длин i, j и $i \times j$ соответственно.
		\item Отсортировать массив структур \texttt{Cost} по стоимости в порядке убывания.
		%\item Повторять для каждого \texttt{Cost} из массива: 
		\item Для каждого $k \in \{1\dots i \times j\}$ повторять:
		\begin{verbatim}
1. i = информация из Cost[k] о номере вместилища;
2. j = информация из Cost[k] о номере груза;
3. Если Cargo[j].is_used = 0:
4.     w = вес Cargo[j];
5.     prev_w_sum = вес уже положенных в Knapsack[i] грузов;
6.     leftover = Knapsack[i].c - prev_w_sum;
7.     Если w =< leftover:
8.         положить j в список принадлежности Knapsack[i];
9.         Cost[j].is_used = 1;
10.	   Иначе:
11.        продолжить цикл;
12. Иначе:
13.    продолжить цикл;
		\end{verbatim}
		
		\item Посчитать сумму стоимостей получившегося набора.
		
		\item Напечатать результат.
		
	\end{enumerate}

\subsection{Программная реализация алгоритма}

	Для реализации был выбран язык программирования \textbf{Haskell}.
	
	Введём некоторые абстракции над типами данных и создадим необходимые программные представления для структур \texttt{Cargo}, \texttt{Knapsack} и \texttt{Cost}:
	\lstset{language=haskell}
	\begin{lstlisting}
type W = Int
type P = Int
type I = Int
type J = Int
type Cargo = (J, Bool, W)
type Knapsack = (I, [J], W)
type Cost = (I, J, P)
	\end{lstlisting}
	
	Создадим некоторые вспомогательные функции:
	
	\begin{itemize}
		\item Функции для удобного взятия первого, второго и третьего элемента кортежа соответственно: 
		\lstset{language=haskell}
		\begin{lstlisting}
	mfst (x, _, _) = x
	msnd (_, x, _) = x
	mthd (_,_,x) = x
		\end{lstlisting}
		\item Функция для обновления элемента с индексом \texttt{i} на элемент \texttt{el}:
		\lstset{language=haskell}
		\begin{lstlisting}
	substitude i el xs = take i xs ++ [el] ++ drop (i + 1) xs
		\end{lstlisting}
		\item Функция для создания списка элементов \texttt{Cargo} из входного списка весов \texttt{w}:
		\lstset{language=haskell}
		\begin{lstlisting}
	makeCargo = makeCargo' 0 
        where
            makeCargo'::Int -> [W] -> [Cargo]
            makeCargo' _ [] = []
            makeCargo' n (w:ws) = (n, False, w) : (makeCargo' (n + 1) ws)
		\end{lstlisting}
		\item Функция для создания списка элементов \texttt{Knapsack} из входного списка весов \texttt{с}:
		\lstset{language=haskell}
		\begin{lstlisting}
	makeKnapsack = makeKnapsack' 0 
        where
            makeKnapsack'::Int -> [C] -> [Knapsack]
            makeKnapsack' _ [] = []
            makeKnapsack' n (c:cs) = (n, [], c) : (makeKnapsack' (n + 1) cs) 
		\end{lstlisting}
		
		\item Функция для создания списка \texttt{Cost} из матрицы выгоды:
		\lstset{language=haskell}
		\begin{lstlisting}
	makeCost::[[P]] -> [Cost]
	makeCost = makeCostI 0
            where
        makeCostI _ [] = []
        makeCostI i (x:xs) = (makeCostIJ i 0 x) ++ (makeCostI (i + 1) xs)
                where
            makeCostIJ i j [] = []  
            makeCostIJ i j (w:ws) = (i, j, w) : (makeCostIJ i (j + 1) ws)
		\end{lstlisting}
	\end{itemize}
	
	Реализуем основной алгоритм:
	\lstset{language=haskell}
	\begin{lstlisting}
    findSoluton cargo ks ((i,j,p):cs) 
                         | msnd (cargo !! j) = findSoluton cargo ks cs
                         | (mthd (ks !! i)) > mthd (cargo !! j) = let
                                 (_, _, cargoW) = cargo !! j
                                 newCargo = substitude j (0, True, 0) cargo
                                 (ki, clst, w) = ks!!i
                                 newKnapsack = substitude i (ki, (j:clst), (w - cargoW)) ks
                                 in findSoluton newCargo newKnapsack cs
                         | otherwice = findSoluton cargo ks cs
	\end{lstlisting}
	
\subsection{Тестовые примеры}

Протестируем алгоритм на следующих данных:

Пусть у нас будут веса $W = \{1,3,4,5,7,6\}$, вместилища $C = \{10,10,7\}$ и матрица стоимостей $C$:

$C = \begin{pmatrix}
  1 & 2 & 3 & 2 & 5 & 8\\
  4 & 10 & 6 & 3 & 4 & 7\\
  7 & 8 & 9 & 2 & 9 & 3
\end{pmatrix}$.

Начнём алгоритм:

\begin{enumerate}

\item Сформируем стоимости:

Knapsack = [(0,0,1),(0,1,2),(0,2,3),(0,3,2),(0,4,5),

(0,5,8),(1,0,4),(1,1,10),(1,2,6),(1,3,3),

(1,4,4),(1,5,7),(2,0,7),(2,1,8),(2,2,9),

(2,3,2),(2,4,9),(2,5,3)].

\item Отсортируем в порядке убывания стоимостей: Knapsack = [(1,1,10),(2,2,9),(2,4,9),(0,5,8),(2,1,8),

(1,5,7),(2,0,7),(1,2,6),(0,4,5),(1,0,4),

(1,4,4),(0,2,3),(1,3,3),(2,5,3),(0,1,2),

(0,3,2),(2,3,2),(0,0,1)].

\item Начнем основной цикл:

	\begin{enumerate}
		\item Положили в рюкзак 1 предмет 1 с весом 3 осталось места: 7
		\item Положим в рюкзак 2 предмет 2 с весом 4 осталось места: 3
		\item Не Положим в рюкзак 2 предмет 4 с весом 7, так как осталось места: 3
		\item Предмет 1 уже лежит в каком-то рюкзаке
		\item Предмет 5 уже лежит в каком-то рюкзаке
		\item Положим в рюкзак 0 предмет 5 с весом 6 осталось места: 4
		\item Предмет 2 уже лежит в каком-то рюкзаке
		\item Положим в рюкзак 2 предмет 0 с весом 1 осталось места: 2
		\item Не Положим в рюкзак 0 предмет 4 с весом 7, так как осталось места: 4
		\item Предмет 0 уже лежит в каком-то рюкзаке
		\item Предмет 2 уже лежит в каком-то рюкзаке
		\item Положим в рюкзак 1 предмет 4 с весом 7 осталось места: 0
		\item Не Положим в рюкзак 1 предмет 3 с весом 5, так как осталось места: 0
		\item Предмет 5 уже лежит в каком-то рюкзаке
		\item Предмет 1 уже лежит в каком-то рюкзаке
		\item Не Положим в рюкзак 0 предмет 3 с весом 		\item 5, так как осталось места: 4
		\item Не Положим в рюкзак 2 предмет 3 с весом 		\item 5, так как осталось места: 2
		\item Предмет 0 уже лежит в каком-то рюкзаке
	\end{enumerate}
	
	\item Посчитаем результат: стоимость всех сложенных предметов будет 38.

\end{enumerate}

Изменим алгоритм. Уберем из него действие 3. 
\begin{enumerate}

\item Сформируем стоимости:

Knapsack = [(0,0,1),(0,1,2),(0,2,3),(0,3,2),(0,4,5),

(0,5,8),(1,0,4),(1,1,10),(1,2,6),(1,3,3),

(1,4,4),(1,5,7),(2,0,7),(2,1,8),(2,2,9),

(2,3,2),(2,4,9),(2,5,3)].

\item Начнем основной цикл:

	\begin{enumerate}
		\item Положили в рюкзак 0 предмет 0 с весом 1 осталось места: 9
		\item Положили в рюкзак 0 предмет 1 с весом 3 осталось места: 6

		\item Не Положим в рюкзак 2 предмет 4 с весом 7, так как осталось места: 3
		\item Положили в рюкзак 0 предмет 2 с весом 4 осталось места: 2

		\item Не положили в рюкзак 0 предмет 3 с весом 5, так как осталось места: 2

		\item Не положили в рюкзак 0 предмет 4 с весом 7, так как осталось места: 2

		\item Не положили в рюкзак 0 предмет 5 с весом 6, так как осталось места: 2

		\item Предмет 0 уже лежит

		\item Предмет 1 уже лежит
		\item Предмет 2 уже лежит
		\item Положили в рюкзак 1 предмет 3 с весом 5 осталось места: 5
		\item Не положили в рюкзак 1 предмет 4 с весом 7, так как осталось места: 5

		\item Не положили в рюкзак 1 предмет 5 с весом 6, так как осталось места: 5

		\item Предмет 0 уже лежит
		\item Предмет 1 уже лежит
		\item Предмет 2 уже лежит
 		\item Предмет 3 уже лежит
		\item Положили в рюкзак 2 предмет 4 с весом 7 осталось места: 0
 		\item Не положили в рюкзак 2 предмет 5 с весом 6, так как осталось места: 0
	\end{enumerate}
	
	\item Посчитаем результат: стоимость всех сложенных предметов будет 18.

\end{enumerate}

\section{Заключение}

Очевидно, что жадный аогоритм сделал перевозку предметов гораздо эффективнее, с его помощью стоимость всех предметов получилась 38, а простым алгоритмом вышло всего 18. Однако, так как жадный алгоритм является ивристическим, а не точным, то возможно существует ещё более выгодное решение.


\section{Список использованных источников}
\begin{enumerate}
\item В. Липский, Комбинаторика для программистов, с. 174. Изд. Москва <<Мир>> 1988г.
\item http://www.math.nsc.ru/LBRT/k5/TPR/lec4.pdf
\item Томас Х. Кормен, Алгоритмы: построение и анализ. Изд. дом <<Вильямс>>.
\end{enumerate}


\end{document}